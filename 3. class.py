
"Класс"                           "Шаблон для создания объектов"         "class Person:"

"Атрибут класса"                  "Данные объекта класса"                "name = Jhon"

"Конструктор"                     "Метод инициализации объекта"	         "def __init__(self, name):"

"Методы экземпляра класса"         "Поведение объекта"	         	     "def что_будет_делать_person(self):"

"Экземпляр класса"	                                                     "Name = Person()"

"Атрибуты экземпляра класса"                                             "Name.name = Nika"

"======================================================================================================================"


class Person:

    a = 100.1
    b = 15.0           # Атрибуты(переменные) класса!
    c = 7.4

print(isinstance(Person.a, float))   # Выдает True или False, проверяет является ли объект типом данных с плавающей запятой!
# print: True

print(getattr(Person, 'x', "Такого атрибута здесь нет!"))   # Проверяет есть ли такая переменная в данном классе или нет,
# print: "Такого атрибута здесь нет!"                       # иначе выведит сообщение "Такого атрибута здесь нет!".
                                                            # Если не написать сообщение, выдаст ошибку!

setattr(Person, 'd',  5)  # Изменяет или добавляет новый атрибут в класс Person.

Person.b = 16.0  # Изменяет атрибут в классе Person.
Person.y = 1200  # Добавляет новый атрибут в класс Person.

print(getattr(Person, 'd', "Такого атрибута здесь нет!"))  # Проверка того, что мы добавили в класс атрибут 'd'.
# print: 5

delattr(Person, 'y')  # Удаляет данный атрибут из класса.

dic = Person.__dict__  # Создает словарь из всех атрибутов класса
print(dic)
# print: {'__module__': '__main__', '__firstlineno__': 16, 'a': 100.1, 'b': 16.0, 'c': 7.4, '__static_attributes__': (),
# '__dict__': <attribute '__dict__' of 'Person' objects>, '__weakref__': <attribute '__weakref__' of 'Person' objects>,
# '__doc__': None, 'd': 5}

print(dic['a'])  # Обращение к словарю
# print: 100.1


"======================================================================================================================"

class Move:
    mov1 = "ходит"
    mov2 = "сидит"          # Атрибуты(переменные) класса!
    mov3 = "лежит"

Name = Move()  # Создали экземпляр класса.

Name.name1 = "Jon"
Name.name2 = "Petr"  # Создали новые атрибуты(переменные) экземпляра класса!
Name.mov4 = "прыгает"

# Name.mov3 - это экземпляр класса + атрибут класса

print(Name.__dict__)  # Создает словарь из всех экзеспляров класса
# print: {'name1': 'Jon', 'name2': 'Petr', 'mov4': 'прыгает'}
print(getattr(Name, 'name1', "Такого атрибута здесь нет!"))  # Проверка того, что мы добавили в экземпляр атрибут 'name1'
# print: Jon
print(f"{Name.name1} {Name.mov4} и {Name.mov1}")
# print: Jon прыгает и ходит
print(f"{Name.name2} {Name.mov2} и {Name.mov3}")
# print: Petr сидит и лежит


"======================================================================================================================"

class Calc:    # Класс
    num = 100  # АТРИБУТ КЛАССА


    def __init__(self, num1 , num2):  # конструктор экземпляра класса.
                                      # __init__ вызывается при создании экземпляров класса

        self.num1 = num1  # атрибуты экземпляра класса (индивидуальные)
        self.num2 = num2  # атрибуты экземпляра класса (индивидуальные)
                                      # АТРИБУТ КЛАССА

    def resul(self):  # метод экземпляра класса
        return self.num1 + self.num2  # Тело метода: возвращает сумму полей num1 и num2 текущего объекта (self).
                                      # АТРИБУТ КЛАССА

    def sravn(self):  # метод экземпляра класса
        if self.num1 > self.num2:
            return self.num1
        else:
            return self.num2          # АТРИБУТ КЛАССА

    def sravn1(self):  # метод экземпляра класса
        if Calc.sravn(res1) > res1.num3:
            return Calc.sravn(res1)
        else:
            return res1.num3          # АТРИБУТ КЛАССА

res1 = Calc(5, 6)  # Создаётся экземпляр класса res1. Вызывается Calc.__new__ → создаётся объект.
                               # Затем Python вызывает Calc.__init__(res1, 5, 6), и внутри res1.num1 и res1.num2
                               # получают значения 5 и 6

res1.num3 = 500  # Создали атрибут экземпляра класса

print(res1.__dict__)                    # {'num1': 5, 'num2': 6}
print(Calc.resul(res1), res1.resul())   # 11 11 два этих результата - это одно и тоже
print(Calc.sravn(res1))                 # 6
print(Calc.sravn1(Calc.sravn(res1)))    # 500


"======================Cпециальные декораторы, которые изменяют поведение метода внутри класса========================="

class A:
    value = 10
    @classmethod  # Метод, который работает с КЛАССОМ:
                  # Получает cls — ссылку на сам класс
                  # Может менять атрибуты класса
                  # Можно вызывать через объект или через класс — всё равно

    def show(cls):  # Определяем метод show, который принимает параметр cls
                    # (так же, как self = объект, тут cls = класс)

        print(cls.value) # Так как cls — это A, то: cls.value → A.value → 10
A.show()
obj = A()
obj.show()


class B:
    value1 = 11
    @staticmethod  # Обычная функция, не связанная ни с экземпляром, ни с классом.
                   # Не получает ни self, ни cls
                   # Не знает, что она находится в классе
                   # Просто лежит внутри класса “для удобства”

    def hello():  # Метод hello
                  # (из-за @staticmethod он НЕ получает self, поэтому пишем просто:)

        print("Привет! Я обычная функция.")  # Когда метод hello() будет вызван, он просто напечатает текст в консоль.
B.hello()
obj = B()
obj.hello()
